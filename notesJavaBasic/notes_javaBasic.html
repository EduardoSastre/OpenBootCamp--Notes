<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
      <meta charset="utf-8">
      <title>Notas Java</title>
</head>

<body>
      <h1>Datos</h1>
      <p>
            Si el tipo de dato empieza por miniscula significa que es primitivo ( No es un objeto y no tiene metodos ), ademas no pueden ser null.
            Si el tipo de dato empieza por mayuscula significa que es no primitivo ( Es un objeto con metodos ), ademas pueden ser null. ( Util para bases de datos )

            Los datos primitivos pueden transformase a no primitivos por medio de los Wrapper.
      </p>

      <img src="images/tiposDatos.png" alt="">

      <h1>Modificador Static</h1>
      <p>
            Se crea dentro de una clase ( como todo en java ), sin embargo este modificar indica que esa variable/metodo con la palabra Static puede invocarse sin necesidad de crearse un nuevo objeto de la clase.
      </p>

      <h1>Modificador de visibilidad: protected</h1>
      <p>
            Ese metodo/atributo solo es visible para la misma clase, clases hijas y todas las clases del mismo paquete.
      </p>

      <h1>Modificar bucles - BREAK Y CONTINUE</h1>
      <p>
            En java hay dos sentencias que nos permiten forzar la salida de un bucle, y estas sentencias son break (para salir completamente del bucle) y continue (para salir de la iteración actual y saltar directamente a la siguiente). <br>

            Estas instrucciones siempre irán dentro de algún if (o else) porque carece de sentido si se va a ejecutar siempre pues en ese caso está claro que hay algo que estamos haciendo mal porque una parte de nuestro código no llegará a ejecutarse
            nunca.
      </p>

      <h1>Metodo Super ( Herencia )</h1>
      <p>
            Se usa en una clase hija para llamar el constructor/metodo de su clase padre.
      </p>

      <h1>Polimorfismo</h1>
      <img src="images/polimorfismo.png" alt="">
      <p>
            Hacer que una clase base se comporte como alguna clase hija.
      </p>
      <img src="images/polimorfismo2.png" alt="">
      <p>
            La palabra reservada <strong>instanceof</strong> checa si un objeto es una instancia de una clase, en el ejemplo de la imagen, se creo un objeto Coche instanciado con la clase cocheElectrico, por lo que este objeto es una instancia de
            Coche y CocheElectrico
      </p>

      <h1>Clase abstracta</h1>
      <p>
            Una clase abstracta no se puede instanciar por si misma, pero si se puede con sus clases hijas.
      </p>

      <h1>Datos tipo String</h1>
      <p>
            '' comillas simples para tipo char y "" comillas dobles para tipo string
      </p>

      <h1>Ciclo for each</h1>
      <img src="images/forEach.png" alt="">


      <h1>Listas</h1>
      <img src="images/listas.png" alt="">

      <h1>Try Catch Finally</h1>
      <img src="images/tryCatchFinally.png" alt="">
      <p>
            Try para "intentar" un codigo, en caso de que haya algun fallo se aplica Catch.
            Esto evita que el programa finalize de repente en caso de algun error.
            Finally es un codigo que sin importar falle o no el try, se va a ejecutar ( podria usarse para cerrar conexiones a bases de datos, etc )
      </p>

      <h1>cin y cout de java ( scanner )</h1>
      <img src="images/cin-cout(Scanner).png" alt="">

      <h1>Java Docs</h1>
      <img src="images/javaDoc.png" alt="">
      <p>
            Para generar documentación. Se agrega arriba de cada clase y metodo.
      </p>

      <h1>Funciones anonimas</h1>
      <p>
            () -> system.out.println("");
      </p>


      <h1>Refactoring</h1>
      <p>
            En el caso de funciones, que sean funciones puras.
      </p>
      <h2>Consolidate conditional</h2>
      <img src="images/CompresionIfs.png" alt="">

      <h1>Tecnicas de Refactoring</h1>
      <a href="https://refactoring.guru/refactoring/catalog" target="_blank"> Refactoring </a>

      <h1>Operador ternario</h1>
      <img src="images/operadorTernario.png" alt="">

      <h1>Constantes</h1>
      <p>
            Convención: En mayusculas separadas por barras bajas ( PRECIO_MINIMO_COMPRA )
      </p>

      <h1> Arrays vs Vectores </h1>
      <p>
            Los Arrays tienen un tamaño definido que no puede cambiarse. Por el contrario los vectores tienen tamaño variable, pueden verse como arrays de tamaño variable.
      </p>
      <ul>
            <li>Vector<Integer> vector = new Vector();</li>
            <li>type[] arrayName = new type[] &nbsp&nbsp&nbsp or &nbsp&nbsp&nbsp type array [] = new type[ maximumQuantity ];</li>
      </ul>

      <p>
            Para agregar datos en Array:
            Array [ index ] = value;

            Para agregar datos en un vector:
            vector.add( value );

            Otros metodos de vector:
            remove()
            size()
            capacity()

            Los vectores por debajo crean un array con determinada capacidad ( capacity() ), cada vez que se supera esa capacidad se copian los datos del array y se transfieren
            a otro array nuevo. Esto es una operación muy costosa, por lo que se debe evitar el resize de un vector.

            Vector<Integer> vector = new Vector( initialCapacity, capacityIncrement );

                  Por default los vectores tienen capacidad de 10 y se va duplicando, esta capacidad inicial se puede manipular con initialCapacity y
                  cuanto se incrementa con capacityIncrement

                  Para recorrer un vector: <br>
                  <img src="images/recorrerVector.png" alt="">

                  Para que la capacidad ( capacity() ) sea igual a su tamaño se usa su metodo: trimToSize().

                  Crecer y decrecer es una operación costosa.

      </p>

      <h1>Vectores vs ArrayList</h1>
      <img src="images/arrayList.png" alt="">
      <p>
            Las arrayList basicamente son iguales a los vectores. Su mayor diferencia radica en cuando aumenta su capacidad al llenarse su array interno.
            Ademas las Array list no tienen el metodo capacity() y estas implementan la interface List.

            Los arrayList no son THREAD SAFE, es decir en multihilos no funcionan correctamente, pero los vectores si.

            En secuencia arrayList y para multihilos Vectores.
            Ambos tienen mismos metodos porque heredan del mismo objeto
      </p>

      <h4>Convertir lista en array</h4>
      <img src="images/convertirListaEnArray.png" alt="">

      <h1>ArrayList vs LinkedList</h1>
      <img src="images/linkedList.png" alt="">
      <p>
            Las linkedList funcionan igual que las arraylist.
            La diferencia es que las arrayList por debajo tienen un array y las linkedList tienen una lista doblemente enlazada.
            ArrayList es mas rapida para buscar datos.
            LinkedList es mas rapida modificando datos.
            Array implementa List y linkedList implementa list y deque
      </p>

      <h4>Crear una linkedList a partir de un ArrayList</h4>
      <img src="images/crearLinkedListConUnaArrayList.png" alt="">

      <h1>BigDecimal</h1>
      <p>
            Para variables que requieran mucha precisión.
            Se usa para datos financieros.
            BigDecimal es una clase, por lo tanto se deben usar sus metodos.
            <img src="images/bigDecimal.png" alt="">
      </p>

      <h1>Maps</h1>
      <img src="images/map.png" alt="">
      <p>
        Deben tener clave unica.
        Para obtener un valor de una clave especifica: <br>
        <img src="images/mapGetValue.png" alt="">

        Con el metodo put(clave) se reemplaza el valor de una clave existente y en caso de no existir la crea.
        Con el metodo replace(clave) se reemplaza el valor de una clave existente y en caso de no existir no hace nada.
        Con el metodo remove(clave) se remueve la clave especficada.
      </p>

      <h4>Recorrer Mapa</h4>
      <img src="images/recorrerMapa.png" alt="">

</html>
